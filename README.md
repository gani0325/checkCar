# ğŸš— checkCar ğŸš—
![16.png](/image/555.png)
- ì•ì°¨ì˜ ìƒí™©ì„ ì•Œë ¤ì¤˜~ ë‚´ ë¶•ë¶•ì´ëŠ” ì˜ìˆë‹ˆ~
- ì•ì°¨ê°€ ê°‘ìê¸° ë©ˆì¶˜ë‹¤ë©´ ë’·ì°¨ëŠ” ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚¬ëŠ”ì§€ ëª¨ë¥¸ë‹¤!
- So, ì•ì°¨ê°€ ë’·ì°¨ì—ê²Œ "ì•ì— ì‚¬ê³ ê°€ ë‚¬ì–´", "ë™ë¬¼ ì¶œëª°!", "ë‚´ ì°¨ê°€ ê³ ì¥ë‚œë“¯" ë“± ë©”ì‹œì§€ë¥¼ ì „ë‹¬í•˜ê³ ì í•œë‹¤!
- ê·¸ë°–ì—ë„, ë‚´ ì°¨ê°€ ì£¼ì°¨ë˜ì–´ìˆê±°ë‚˜ ë©ˆì¶°ìˆì„ ë•Œ ì•±(tcp)ìœ¼ë¡œ "ë‚˜ ì ì‹œ ì£¼ì°¨ì¤‘", "ê¸‰ í™”ì¥ì‹¤!" ë“± ë©”ì‹œì§€ë¥¼ ì „ë‹¬í•œë‹¤!
- ìš°ë¦¬ì˜ ìµœì¢… ëª©í‘œëŠ”
  - 1. ì¡°ì´ìŠ¤í‹± ë²„íŠ¼ 4ê°œë¡œ ğŸ”Šì°¨ ì‚¬ê³ , ğŸ¦Šë™ë¬¼ ì¶œëª°, ğŸ‘§ ì°¨ì•ˆì— ì•„ê¸° ìˆìŒ, âš’ï¸ì°¨ ê³ ì¥ì˜ ë©”ì‹œì§€ë¡¤ LCD íŒìœ¼ë¡œ ë³´ë‚¸ë‹¤
    2. TCP í†µì‹ ğŸ“¤ ì„ í†µí•´ ë©€ë¦¬ì„œë„ ë³´ë‚´ê³  ì‹¶ì€ ë©”ì‹œì§€ë¥¼ LCD íŒìœ¼ë¡œ ë³´ë‚¸ë‹¤
    3. ì¡°ì´ìŠ¤í‹± íšŒì „ê¸°ğŸ•¹ï¸ë¡œ ìš´ì „ëŒ€ë¼ ìƒê°í•˜ê³  ì „ì§„ğŸ”µ, ìš°/ì¢ŒíšŒì „ + ì „ì§„ğŸ”µğŸŸ¢, í›„ì§„ğŸ”´, ìš°/ì¢ŒíšŒì „ + í›„ì§„ğŸ”´ğŸŸ¢ í•  ë•Œë§ˆë‹¤ í•´ë‹¹ LED ë¥¼ ê¹œë¹¡ì¸ë‹¤

### ğŸ›ï¸ 2ì¡°ì˜ ê·œì¹™
**1ï¸âƒ£ commit message** 

```c
â•[Feat] : ê¸°ëŠ¥ ì¶”ê°€
ğŸš€[Chore] : ì‹¤í–‰ íŒŒì¼ ë° ìˆ˜ì • ì‹œ 
ğŸš§[Refactor] : ì½”ë“œ ìˆ˜ì • (ë¦¬íŒ©í† ë§)
ğŸ“ƒ[Memo] : ì£¼ì„ ìˆ˜ì •
ğŸš¨[Alert] : ê¸°ëŠ¥ ì˜¤ë¥˜ ì‹œ
âš™ï¸[Setting] : ì´ˆê¸° ë° í™˜ê²½ ì„¤ì •
ğŸ“¤[Move] : íŒŒì¼ ì˜®ê¸°ê¸°
âœ‚ï¸[Remove] : íŒŒì¼ ì‚­ì œ
```

**2ï¸âƒ£ ê¹ƒí—ˆë¸Œ push ì‹œ ğŸš¨ ì•Œë¦¬ê¸° (ì¶©ëŒ ë°œìƒ!! Pull í•˜ê³  ìˆ˜ì •í•˜ì„¸ìš”!!)**

**3ï¸âƒ£ 1ì¼ 1 issue ì‘ì„±**

**4ï¸âƒ£ dev branch ì— 1ì°¨ Merge, main branch ì— ìµœì¢… Merge**

# ğŸš— í”„ë¡œì íŠ¸ ğŸš—
### ğŸ‘¨â€ğŸ’» 1. í”„ë¡œì íŠ¸ ê°„íŠ¸ ì°¨íŠ¸
- ì£¼ì œ ì •í•˜ê¸° (November 3, 2023 ~ November 5, 2023)
- ë¡œì§ êµ¬ìƒí•˜ê¸° (November 6, 2023)
- í†µì‹  êµ¬í˜„ & LCDì— ì¶œë ¥ (November 6, 2023 ~ November 9, 2023)
- ì•„ë‘ì´ë…¸ë¡œ ê°’ ë°›ì•„ì˜¤ê¸° (November 7, 2023 ~ November 9, 2023)
- checkCar ë°œí‘œ í•˜ê¸° (November 10, 2023)

### ğŸ‘¨â€ğŸ’» 2. ì‘ì—…ìˆœì„œ
- ê°ì²´ì§€í–¥ ë§Œë“¤ê¸°
    - ê°ì²´ joystickê³¼ button í•©ì„±ê´€ê³„ë¥¼ ì´ìš©í•´ pinê³¼ pinModeë¶€ë¶„ ìº¡ìŠí™”, ì•„ë‘ì´ë…¸ì™€ Cì™€ C++ í†µí•©êµ¬í˜„
```
//arduino.ino
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <Arduino.h>
#include "joystick.h"
#include "button.h"
#include "xystick.h"
#include "led.h"
#include "lcd.h"

// joystick ê°ì²´ ìƒì„±
joystick_t *joystick;   

void setup()
{
  Serial.begin(9600);    // ì‹œë¦¬ì–¼ í†µì‹ ì„ ì‹œì‘í•˜ë©°, í†µì‹ ì†ë„ëŠ” 9600
  //joystick ìƒì„±
  joystick = (joystick_t *)joystick_new(); // joystick ê°ì²´ ë©”ëª¨ë¦¬ í• ë‹¹
  joystick_ctor(joystick);                 // joystick ê°ì²´ ì‹œê·¸ë‹ˆì²˜ë¡œ ìƒì„±ì í•¨ìˆ˜ì•ˆì— pinê³¼ pinModeí• ë‹¹ì´ ìˆë‹¤.
}

void loop()
{
  joystick_control(joystick);
  joystick_lcd_print(joystick);
}
```

- íšŒì˜ë¡
- Tasks Board ì¹¸ë°˜ë³´ë“œ

### ğŸ‘¨â€ğŸ’» 3. ë‹¤ì´ì–´ê·¸ë¨
```jsx
			arduino_main() ----Serial--- client_main() -----TCP-----server_main()
                              |                            |                         |
                              |                            |                         |
                        button_click()                     |                         |
                              |                            |                         |
                              V                            |                         |  
                          LCDprint() <-------------- Serial_write() <---------->  accept()   
                               
```
- 231103
![16.png](/image/ã…‚.png)
![16.png](/image/ã…ˆ.png)

- 231106
![16.png](/image/q.png)

- 231107
![16.png](/image/w.png)

- 231110
![16.png](/image/6666.png)


### ğŸ‘¨â€ğŸ’» 4. ì†ŒìŠ¤ì½”ë“œ ë¶„ì„

- **network**
    
    **ğŸš— server.c**
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <arpa/inet.h>
    #include <sys/socket.h>
    
    #define BUF_SIZE 16
    void error_handling(char *message);
    
    int main(int argc, char *argv[])
    {
       // ì„œë²„, í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ íŒŒì¼ë””ìŠ¤í¬ë¦½í„° ë³€ìˆ˜ ì„ ì–¸
       int serv_sock, clnt_sock;
       char message[BUF_SIZE];
       int str_len, i;
    
       // sockaddr_in êµ¬ì¡°ì²´ ë³€ìˆ˜ ì„ ì–¸
       struct sockaddr_in serv_adr, clnt_adr;
       socklen_t clnt_adr_sz;
    
       if(argc != 2)
       {
          printf("Usage : %s <port>\n", argv[0]);
          exit(1);
       }
    
       // ----------- 1. Create socket object ------------------
       // socket() : socket ìƒì„± & socket discriptor
       serv_sock = socket(PF_INET, SOCK_STREAM, 0);
       if(serv_sock == -1)
          error_handling("socket() error");
    
       // ----------- 2. Bind the socket file ------------------
       // serv_sockì— bind ë¡œ ì£¼ì†Œ ë„£ê¸° ìœ„í•œ ë°‘ì‘ì—…
       memset(&serv_adr, 0, sizeof(serv_adr));
    
       // Prepare the address
       serv_adr.sin_family = AF_INET;                     // type : IPv4
       serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);      // ipì£¼ì†Œ
       serv_adr.sin_port = htons(atoi(argv[1]));          // í¬íŠ¸ë²ˆí˜¸
    
       // bind()ë¡œ ì„œë²„ ì†Œì¼“ì— ì£¼ì†Œì •ë³´ í• ë‹¹
       if(bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr)) == -1)
          error_handling("bind() error");
    
       // ----------- 3. Prepare backlog ------------------
       // listen()ìœ¼ë¡œ ì„œë²„ì†Œì¼“ìœ¼ë¡œ ì˜¤ëŠ” í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ ëŒ€ê¸°
       if(listen(serv_sock, 5) == -1)
          error_handling("listen() error");
    
       clnt_adr_sz = sizeof(clnt_adr);
    
       for(i = 0; i < 5; i++)
       {
          printf("Listen....\n");
          
          // ----------- 4. Start accepting clients ---------
          // í´ë¼ì´ì–¸íŠ¸ ì ‘ì† ìš”ì²­ ëŒ€ê¸° ë° ìˆ˜ë½, í´ë¼ì´ì–¸íŠ¸ì™€ì˜ í†µì‹ ì„ ìœ„í•œ ìƒˆ socket ìƒì„±
          clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_sz);
          if(clnt_sock == -1)
             error_handling("accept() error");
          else
             printf("Connected client %d \n", i + 1);
    
          // í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ì „ì†¡ëœ ìë£Œ ìˆ˜ì‹ 
          // read(int fd, void *buff, size_t nbytes)
          while((str_len = read(clnt_sock, message, BUF_SIZE)) != 0)
             // í´ë¼ì´ì–¸íŠ¸ë¡œ ìë£Œ ì†¡ì‹ 
             // write(int fd, const void *buf, size_t nbytes);
             write(clnt_sock, message, str_len);
          
          // í†µì‹ ì„ ì™„ë£Œí•˜ë©´ socket ì„ ì†Œë©¸
          close(clnt_sock);
       }
    
       // í†µì‹ ì„ ì™„ë£Œí•˜ë©´ socket ì„ ì†Œë©¸
       close(serv_sock);
       return 0;
    }
    
    void error_handling(char *message)
    {
       fputs(message, stderr);
       fputc('\n', stderr);
       exit(1);
    }
    ```
    
    **ğŸš— client.c**
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <arpa/inet.h>
    #include <sys/socket.h>
    
    #include <fcntl.h>
    #include <termios.h>
    
    #define BUF_SIZE 16
    void error_handling(char *message);
    
    typedef struct
    {
       // íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° : ì–´ë– í•œ í†µì‹  í¬íŠ¸ë¥¼ ì—´ì—ˆì„ ë•Œ ì»´í“¨í„°ê°€ ì°¾ì•„ê°€ê¸° ì‰½ê²Œ ì •ìˆ˜ë¡œ ìˆ«ì ë§¤ê¹€
       int fd;
    } SerialPort;
    
    // device : ì—´ê³  ì‹¶ì€ ì‹œë¦¬ì–¼ í¬íŠ¸ì˜ ì´ë¦„
    int serial_open(SerialPort *port, const char *device)
    {
       // open : ë¬¸ìì—´ë¡œ ì„ ì–¸ëœ ê²½ë¡œ(device)ë¥¼ ë°›ì•„ì„œ íŒŒì¼ ë””ìŠ¤í¬ë¦½í„°(fd)ë¡œ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
       port->fd = open(device, O_RDWR | O_NOCTTY | O_NDELAY);
       if (port->fd == -1)
       {
          perror("Unable to open port");
          return -1;
       }
    
       // ì‹œë¦¬ì–¼ í†µì‹  í™˜ê²½ì„ ì„¤ì •í•˜ê¸° ìœ„í•´ termios êµ¬ì¡°ì²´ë¥¼ ì„ ì–¸
       struct termios options;
    
       memset(&options, 0, sizeof(options));
    
       // ì‹œë¦¬ì–¼ í¬íŠ¸ ì´ˆê¸°í™”
       tcflush(port->fd, TCIFLUSH); 
    
       // Terminer Control ëª¨ë“œ ì„¤ì •ì„ ìœ„í•´ì„œ Get
       tcgetattr(port->fd, &options); 
       cfsetispeed(&options, B9600); // Set baud rate to 9600 (adjust as needed)
       cfsetospeed(&options, B9600);
    
       options.c_cflag |= CS8;     // 8 data bits -> ë¬¸ì í¬ê¸° ë§ˆìŠ¤í¬
       options.c_cflag &= ~PARENB; // No parity -> PARENBÂ : ì¶œë ¥ ì‹œ íŒ¨ë¦¬í‹° ìƒì„±ì„ í™œì„±í™”í•˜ê³  ì…ë ¥
       options.c_cflag &= ~CSTOPB; // One stop bit -> CSTOPB : Stop bit ìˆ˜ 1ê°œ
       // options.c_cflag &= ~CSIZE;  // Mask the character size bits
       
       // Serial Portì— ìƒˆ ì„¤ì • Set
       // ì‹œë¦¬ì–¼ í¬íŠ¸ì— ì„¤ì • ì…ë ¥ (TCSANOW : ì¦‰ì‹œ ì†ì„±ì„ ë³€ê²½ì‹œì¼œë¼)
       tcsetattr(port->fd, TCSANOW, &options);
    
       return 0;
    }
    
    void serial_close(SerialPort *port)
    {
       close(port->fd);
       port->fd = -1;
    }
    
    int serial_read(SerialPort *port, char *buffer, size_t size)
    {
       // Serial Portë¡œë¶€í„° ë°ì´í„° ìˆ˜ì‹ 
       // readì— ì˜í•´ì„œ ì‹¤ì œë¡œ ì½í˜€ì§„ ë¬¸ìì˜ ê°œìˆ˜ë¥¼ ê°–ê²Œ ë¨
       return read(port->fd, buffer, size);
    }
    
    ssize_t serial_write(SerialPort *port, char *buffer, size_t size)
    {
       // Serial Portìœ¼ë¡œ ë°ì´í„° ì†¡ì‹ 
       return write(port->fd, buffer, size);
    }
    
    int main(int argc, char *argv[])
    {
       int sock;
       char message[BUF_SIZE] = {0, };
       int str_len;
    
       // sockaddr_in êµ¬ì¡°ì²´ ë³€ìˆ˜ ì„ ì–¸
       struct sockaddr_in serv_adr;
    
       if (argc != 3)
       {
          printf("Usage : %s <IP> <port> \n", argv[0]);
          exit(1);
       }
    
       // ----------- 1. Create socket object ------------------
       // socket() : socket ìƒì„± & socket discriptor
       sock = socket(PF_INET, SOCK_STREAM, 0);
       if (sock == -1)
          error_handling("socket() error");
    
       // serial port
       SerialPort port;
       if (serial_open(&port, "/dev/ttyACM0") == -1)
       {
          return -1;
       }
    
       // ------------ 2. Connect to server-- ------------------
       // serv_sockì— bind ë¡œ ì£¼ì†Œ ë„£ê¸° ìœ„í•œ ë°‘ì‘ì—…
       memset(&serv_adr, 0, sizeof(serv_adr));
    
       // Prepare the address
       serv_adr.sin_family = AF_INET;                     // type : IPv4
       serv_adr.sin_addr.s_addr = inet_addr(argv[1]);     // ipì£¼ì†Œ
       serv_adr.sin_port = htons(atoi(argv[2]));          // í¬íŠ¸ë²ˆí˜¸
    
       // ëŒ€ìƒ ì„œë²„ ì†Œì¼“ì— ì£¼ì†Œ í• ë‹¹
       // ì£¼ì†Œ ì •ë³´ì— ì„œë²„ì˜ ì£¼ì†Œì™€ í¬íŠ¸ ë²ˆí˜¸ë¥¼ ì§€ì •í•˜ê³  ì„œë²„ì™€ ì—°ê²° ì‹œë„
       if (connect(sock, (struct sockaddr *)&serv_adr, sizeof(serv_adr)) == -1)
          error_handling("connect() error!");
       else
          puts("Connect........");
    
       while (1)
       {
          fputs("Input message(Q to quit) : ", stdout);
          fgets(message, BUF_SIZE, stdin);
    
          if (!strcmp(message, "q\n") || !strcmp(message, "Q\n"))
             break;
          
          // í´ë¼ì´ì–¸íŠ¸ë¡œ ìë£Œë¥¼ ì†¡ì‹ í•œë‹¤
          // write(int fd, const void *buf, size_t nbytes);
          write(sock, message, strlen(message));
    
          // í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ì „ì†¡ëœ ìë£Œ ìˆ˜ì‹ í•œë‹¤
          // read(int fd, void *buff, size_t nbytes)
          str_len = read(sock, message, BUF_SIZE - 1);
          message[str_len] = 0;
    
          printf("Message form server : %s", message);
    
          // serial port ë¡œ message ì „ë‹¬
          serial_write(&port, message, sizeof(message));      
       }
       
       // í†µì‹  í¬íŠ¸ë¥¼ ë‹«ì•„ ì‚¬ìš©ì„ ì¤‘ì§€
       serial_close(&port);   
    
       close(sock);   
       return 0;
    }
    
    void error_handling(char *message)
    {
       fputs(message, stderr);
       fputc('\n', stderr);
       exit(1);
    }
    ```
    
- **arduino**
```arduino
//joystick.c
#include <stdint.h> //int xë¹„íŠ¸ ê°™ì€ ìë£Œí˜•ì„ ì“°ê¸°ìœ„í•´ì„œ
#include <Arduino.h>
#include "joystick.h"
#include "button.h"
#include "xystick.h"
#include "led.h"
#include "lcd.h"

typedef struct joystick_t
{
	struct button_t *but[5]; // ë²„íŠ¼ 4ê°œì˜ ì£¼ì†Œ ë°°ì—´ì— í• ë‹¹. ë§ˆì§€ë§‰indexëŠ” ë¹ˆ return ê°’ì„ ë°›ê¸°ìœ„í•¨.
	struct xystick_t *xystick;
} joystick_t;

char selected_button;
uint8_t pin_status[4];
int *joystick_XYaxis_value[2];
char data[COLUMN + 1];

void *joystick_new()
{
	return (void *)malloc(sizeof(joystick_t));
}

void joystick_ctor(joystick_t *joystick_obj) // joystick ê°ì²´ë¥¼ ì‹œê·¸ë‹ˆì²˜ë¡œ ë°›ìŒ ë°›ì€ ê°ì²´ëŠ” ëª¨ë‘ objë¡œ ëª…ì¹­
{
	for (uint8_t pin = 2, index = 0; pin < 6; pin++, index++) // ë°°ì—´ì„ í•˜ë‚˜ì”© ë°˜ë³µí•˜ë©° pinê³¼ pinMode ì´ˆê¸°í™”
	{
		joystick_obj->but[index] = button_4new(); // ë°°ì—´ í•˜ë‚˜ì— ë²„íŠ¼ 1ê°œì— ëŒ€í•œ í•˜ë‚˜ì˜ buttonê°ì²´ ë©”ëª¨ë¦¬í• ë‹¹. buttonê°ì²´ ìƒì„±
		if (index == 0)
		{
			joystick_obj->but[index]->button_name = 'A';
		}
		else if (index == 1)
		{
			joystick_obj->but[index]->button_name = 'B';
		}
		else if (index == 2)
		{
			joystick_obj->but[index]->button_name = 'C';
		}
		else if (index == 3)
		{
			joystick_obj->but[index]->button_name = 'D';
		}
		button_4ctor(joystick_obj->but[index], pin, INPUT_PULLUP); // buttonê°ì²´ì— pinê³¼ pinModeí• ë‹¹
	}
	joystick_obj->xystick = xystick_new();
	lcd_init();
}

void joystick_lcd_print(joystick_t* joystick_obj)
{
	char clicked_button = 'E'; // ì´ˆê¸°í™”
	clicked_button = joystick_digitalRead(joystick_obj);
	if (clicked_button == 'A')
	{ // ifë¬¸ì„ ì´ìš©í•˜ì—¬ ê° ë²„íŠ¼ì´ ëˆŒë¦¬ë©´ ì•ŒíŒŒë²³ì´ ì‹œë¦¬ì–¼ëª¨ë‹ˆí„°ì— ì¶œë ¥ë˜ë„ë¡ ì„¤ì •
		char data[COLUMN + 1] = "front car!";
		lcd_print(data);
	}
	if (clicked_button == 'B')
	{
		char data[COLUMN + 1] = "front animal!";
		lcd_print(data);
	}
	if (clicked_button == 'C')
	{
		char data[COLUMN + 1] = "baby in car";
		lcd_print(data);
	}
	if (clicked_button == 'D')
	{
		char data[COLUMN + 1] = "broken car";
		lcd_print(data);
	}
};

char joystick_digitalRead(joystick_t *joystick_obj)
{
	for (int index = 0; index < 4; index++)
	{
		pin_status[index] = clicked_button(joystick_obj->but[index]);
	}
	if (pin_status[0] == LOW)
	{
		return joystick_obj->but[0]->button_name;
	}
	else if (pin_status[1] == LOW)
	{
		return joystick_obj->but[1]->button_name;
	}
	else if (pin_status[2] == LOW)
	{
		return joystick_obj->but[2]->button_name;
	}
	else if (pin_status[3] == LOW)
	{
		return joystick_obj->but[3]->button_name;
	}
	return 'E';
}

void joystick_control(joystick_t *joystick_obj)
{
	joystick_XYaxis_value[X_PIN_INDEX] = xstick_analogRead(joystick_obj->xystick);
	joystick_XYaxis_value[Y_PIN_INDEX] = ystick_analogRead(joystick_obj->xystick);

	if (joystick_XYaxis_value[X_PIN_INDEX] == 493)
	{
		if (joystick_XYaxis_value[Y_PIN_INDEX] > 515)
		{
			joystick_XYstick_forward(joystick_obj->xystick);
		}
	}
	if (joystick_XYaxis_value[X_PIN_INDEX] == 493)
	{
		if (joystick_XYaxis_value[Y_PIN_INDEX] < 515)
		{
			joystick_XYstick_back(joystick_obj->xystick);
		}
	}
	if (joystick_XYaxis_value[X_PIN_INDEX] < 493)
	{
		joystick_XYstick_left(joystick_obj->xystick);
	}
	if (joystick_XYaxis_value[X_PIN_INDEX] > 493)
	{
		joystick_XYstick_right(joystick_obj->xystick);
	}
	if (joystick_XYaxis_value[X_PIN_INDEX] == 493)
	{
		if (joystick_XYaxis_value[Y_PIN_INDEX] == 515)
		{
			joystick_XYstick_fixed(joystick_obj->xystick);
		}
	}
}
```

### ğŸ‘¨â€ğŸ’» 5. í”„ë¡œì íŠ¸ ì„±ê³¼ ê²°ê³¼
- **ğŸš— LCD íŒì— ë’·ì°¨ì— ìƒí™© ì•Œë¦¬ê¸°**
    1. ì¡°ì´ìŠ¤í‹± ë²„íŠ¼ 4ê°œë¡œ ì§€ì •ëœ ìƒí™© ì•Œë¦¬ê¸°
        - ì¡°ì´ìŠ¤í‹± ë²„íŠ¼
            - Aë²„íŠ¼ : front car!
            ![16.png](/image/car.jpg)
            - Bë²„íŠ¼ : front animal!
            ![16.png](/image/animal.jpg)
            - Cë²„íŠ¼ : baby in car
            ![16.png](/image/baby.jpg)
            - Dë²„íŠ¼ : broken car
            ![16.png](/image/broken.jpg)
    2. TCP/IP í†µì‹ ìœ¼ë¡œ ìš´ì „ë¿ë§Œ ì•„ë‹ˆë¼ ì •ì°¨ì¤‘ì—ë„ ë©”ì‹œì§€ ì „ë‹¬í•˜ê¸°
    ![16.png](/image/T.jpg)

- **ğŸš— ì¡°ì´ìŠ¤í‹± (ìš´ì „ëŒ€) ìœ¼ë¡œ LED ì œì–´í•˜ê¸°**
    1. ì „ì§„, ì¢Œ/ìš°íšŒì „, í›„ì§„ í•  ë•Œë§ˆë‹¤ LED ì œì–´
        - ì „ì§„ : íŒŒë‘
        ![16.png](/image/ì „ì§„.png)
        - ì¢Œ/ì „ì§„ : íŒŒë‘/ì´ˆë¡
        ![16.png](/image/ì¢ŒíšŒì „.png)
        - ìš°/ì „ì§„ : íŒŒë‘/ì´ˆë¡
        ![16.png](/image/ìš°íšŒì „.png)
        - í›„ì§„ : ë¹¨ê°•
        ![16.png](/image/í›„ì§„.png)
        - ì¢Œ/í›„ì§„ : ë¹¨ê°•/ì´ˆë¡
        ![16.png](/image/ì¢Œí›„ì§„.png)
        - ìš°/í›„ì§„ : ë¹¨ê°•/ì´ˆë¡
        ![16.png](/image/ìš°í›„ì§„.png)


- ê°ì²´ ì§€í–¥ ì½”ë“œë¡œ ë°”ê¿€ ì‹œ ë©”ëª¨ë¦¬ ìš©ëŸ‰ ë¹„êµí•˜ê¸°

 ![16.png](/image/ì•„ë‘ì´ë…¸ì €ì¥ìš©ëŸ‰1.png)
 ì ˆì°¨ì§€í–¥ ì½”ë“œë¡œ êµ¬í˜„ 

 ![16.png](/image/ì•„ë‘ì´ë…¸ì €ì¥ìš©ëŸ‰2.png)
 ê°ì²´ì§€í–¥ ì½”ë“œë¡œ êµ¬í˜„

 flush ë©”ëª¨ë¦¬ì˜ ìš©ëŸ‰ì´ ì¤„ì–´ë“¤ê³  SRamìš©ëŸ‰ì€ ëŠ˜ì–´ë‚¬ë‹¤.