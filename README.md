# ğŸš— checkCar ğŸš—
![16.png](/image/555.png)
- ì•ì°¨ì˜ ìƒí™©ì„ ì•Œë ¤ì¤˜~ ë‚´ ë¶•ë¶•ì´ëŠ” ì˜ìˆë‹ˆ~
- ì•ì°¨ê°€ ê°‘ìê¸° ë©ˆì¶˜ë‹¤ë©´ ë’·ì°¨ëŠ” ë¬´ìŠ¨ ì¼ì´ ì¼ì–´ë‚¬ëŠ”ì§€ ëª¨ë¥¸ë‹¤!
- So, ì•ì°¨ê°€ ë’·ì°¨ì—ê²Œ "ì•ì— ì‚¬ê³ ê°€ ë‚¬ì–´", "ë™ë¬¼ ì¶œëª°!", "ë‚´ ì°¨ê°€ ê³ ì¥ë‚œë“¯" ë“± ë©”ì‹œì§€ë¥¼ ì „ë‹¬í•˜ê³ ì í•œë‹¤!
- ê·¸ë°–ì—ë„, ë‚´ ì°¨ê°€ ì£¼ì°¨ë˜ì–´ìˆê±°ë‚˜ ë©ˆì¶°ìˆì„ ë•Œ ì•±(tcp)ìœ¼ë¡œ "ë‚˜ ì ì‹œ ì£¼ì°¨ì¤‘", "ê¸‰ í™”ì¥ì‹¤!" ë“± ë©”ì‹œì§€ë¥¼ ì „ë‹¬í•œë‹¤!
- ìš°ë¦¬ì˜ ìµœì¢… ëª©í‘œëŠ”
  - 1. ì¡°ì´ìŠ¤í‹± ë²„íŠ¼ 4ê°œë¡œ ğŸ”Šì°¨ ì‚¬ê³ , ğŸ¦Šë™ë¬¼ ì¶œëª°, ğŸ‘§ ì°¨ì•ˆì— ì•„ê¸° ìˆìŒ, âš’ï¸ì°¨ ê³ ì¥ì˜ ë©”ì‹œì§€ë¡¤ LCD íŒìœ¼ë¡œ ë³´ë‚¸ë‹¤
    2. TCP í†µì‹ ğŸ“¤ ì„ í†µí•´ ë©€ë¦¬ì„œë„ ë³´ë‚´ê³  ì‹¶ì€ ë©”ì‹œì§€ë¥¼ LCD íŒìœ¼ë¡œ ë³´ë‚¸ë‹¤
    3. ì¡°ì´ìŠ¤í‹± íšŒì „ê¸°ğŸ•¹ï¸ë¡œ ìš´ì „ëŒ€ë¼ ìƒê°í•˜ê³  ì „ì§„ğŸ”µ, ìš°/ì¢ŒíšŒì „ + ì „ì§„ğŸ”µğŸŸ¢, í›„ì§„ğŸ”´, ìš°/ì¢ŒíšŒì „ + í›„ì§„ğŸ”´ğŸŸ¢ í•  ë•Œë§ˆë‹¤ í•´ë‹¹ LED ë¥¼ ê¹œë¹¡ì¸ë‹¤

### ğŸ›ï¸ 2ì¡°ì˜ ê·œì¹™
**1ï¸âƒ£ commit message** 

```c
â•[Feat] : ê¸°ëŠ¥ ì¶”ê°€
ğŸš€[Chore] : ì‹¤í–‰ íŒŒì¼ ë° ìˆ˜ì • ì‹œ 
ğŸš§[Refactor] : ì½”ë“œ ìˆ˜ì • (ë¦¬íŒ©í† ë§)
ğŸ“ƒ[Memo] : ì£¼ì„ ìˆ˜ì •
ğŸš¨[Alert] : ê¸°ëŠ¥ ì˜¤ë¥˜ ì‹œ
âš™ï¸[Setting] : ì´ˆê¸° ë° í™˜ê²½ ì„¤ì •
ğŸ“¤[Move] : íŒŒì¼ ì˜®ê¸°ê¸°
âœ‚ï¸[Remove] : íŒŒì¼ ì‚­ì œ
```

**2ï¸âƒ£ ê¹ƒí—ˆë¸Œ push ì‹œ ğŸš¨ ì•Œë¦¬ê¸° (ì¶©ëŒ ë°œìƒ!! Pull í•˜ê³  ìˆ˜ì •í•˜ì„¸ìš”!!)**

**3ï¸âƒ£ 1ì¼ 1 issue ì‘ì„±**

**4ï¸âƒ£ dev branch ì— 1ì°¨ Merge, main branch ì— ìµœì¢… Merge**

# ğŸš— í”„ë¡œì íŠ¸ ğŸš—
### ğŸ‘¨â€ğŸ’» 1. í”„ë¡œì íŠ¸ ê°„íŠ¸ ì°¨íŠ¸
- ì£¼ì œ ì •í•˜ê¸° (November 3, 2023 ~ November 5, 2023)
- ë¡œì§ êµ¬ìƒí•˜ê¸° (November 6, 2023)
- í†µì‹  êµ¬í˜„ & LCDì— ì¶œë ¥ (November 6, 2023 ~ November 9, 2023)
- ì•„ë‘ì´ë…¸ë¡œ ê°’ ë°›ì•„ì˜¤ê¸° (November 7, 2023 ~ November 9, 2023)
- checkCar ë°œí‘œ í•˜ê¸° (November 10, 2023)

### ğŸ‘¨â€ğŸ’» 2. ì‘ì—…ìˆœì„œ
- ê°ì²´ì§€í–¥ ë§Œë“¤ê¸°
    - ê°ì²´ joystickê³¼ button í•©ì„±ê´€ê³„ë¥¼ ì´ìš©í•´ pinê³¼ pinModeë¶€ë¶„ ìº¡ìŠí™”, ì•„ë‘ì´ë…¸ì™€ Cì™€ C++ í†µí•©êµ¬í˜„
```
//joystick.h
#pragma once       // híŒŒì¼ ë°˜ë³µ ì œì–´
struct joystick_t; // joystick ê°ì²´ ì „ë°©ì„ ì–¸

#ifdef __cplusplus // ì»´íŒŒì¼ëŸ¬ê°€ g++ì´ë©´ ë‹¤ìŒê³¼ ê°™ì´ í•´ë¼.
extern "C"         // g++ì»´íŒŒì¼ëŸ¬ì—ì„œ Cì–¸ì–´ê°€ ì»´íŒŒì¼ ë˜ë„ë¡ í•˜ëŠ” ì½”ë“œ
{
#endif
    void *joystick_new();                    // : joystickê°ì²´ í• ë‹¹
    void joystick_ctor(struct joystick_t *); // ì¡°ì´ìŠ¤í‹± ê°ì²´ìƒì„±ì, pinê³¼ pinMode í• ë‹¹ì´ í•¨ìˆ˜ ì‹¤í–‰.
#ifdef __cplusplus                           // ì»´íŒŒì¼ëŸ¬ê°€ g++ì´ë©´ ë‹¤ìŒê³¼ ê°™ì´ í•´ë¼.
}
#endif

//button.h
#pragma once
struct button_t;
#ifdef __cplusplus // avr-gccì»´íŒŒì¼ëŸ¬ê°€ c++ë¥¼ ì»´íŒŒì¼ í•  ë•Œ ë‹¤ìŒê³¼ ê°™ì´ í•´ë¼.
extern "C"         // ì»´íŒŒì¼ëŸ¬ì—ì„œ Cì–¸ì–´ê°€ ì»´íŒŒì¼ ë˜ë„ë¡ í•˜ëŠ” ì½”ë“œ
{
#endif
    void *button_4new(); // button_t ê°ì²´í• ë‹¹
    void button_4ctor(struct button_t *, int8_t, int8_t);

#ifdef __cplusplus
}
#endif
```

- íšŒì˜ë¡
- Tasks Board ì¹¸ë°˜ë³´ë“œ

### ğŸ‘¨â€ğŸ’» 3. ë‹¤ì´ì–´ê·¸ë¨
```jsx
			arduino_main() ----Serial--- client_main() -----TCP-----server_main()
                              |                            |                         |
                              |                            |                         |
                        button_click()                     |                         |
                              |                            |                         |
                              V                            |                         |  
                          LCDprint() <-------------- Serial_write() <---------->  accept()   
                               
```
- 231103
![16.png](/image/ã…‚.png)
![16.png](/image/ã…ˆ.png)

- 231106
![16.png](/image/q.png)

- 231107
![16.png](/image/w.png)

- 231110
![16.png](/image/6666.png)


### ğŸ‘¨â€ğŸ’» 4. ì†ŒìŠ¤ì½”ë“œ ë¶„ì„

- **network**
    
    **ğŸš— server.c**
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <arpa/inet.h>
    #include <sys/socket.h>
    
    #define BUF_SIZE 16
    void error_handling(char *message);
    
    int main(int argc, char *argv[])
    {
       // ì„œë²„, í´ë¼ì´ì–¸íŠ¸ ì†Œì¼“ íŒŒì¼ë””ìŠ¤í¬ë¦½í„° ë³€ìˆ˜ ì„ ì–¸
       int serv_sock, clnt_sock;
       char message[BUF_SIZE];
       int str_len, i;
    
       // sockaddr_in êµ¬ì¡°ì²´ ë³€ìˆ˜ ì„ ì–¸
       struct sockaddr_in serv_adr, clnt_adr;
       socklen_t clnt_adr_sz;
    
       if(argc != 2)
       {
          printf("Usage : %s <port>\n", argv[0]);
          exit(1);
       }
    
       // ----------- 1. Create socket object ------------------
       // socket() : socket ìƒì„± & socket discriptor
       serv_sock = socket(PF_INET, SOCK_STREAM, 0);
       if(serv_sock == -1)
          error_handling("socket() error");
    
       // ----------- 2. Bind the socket file ------------------
       // serv_sockì— bind ë¡œ ì£¼ì†Œ ë„£ê¸° ìœ„í•œ ë°‘ì‘ì—…
       memset(&serv_adr, 0, sizeof(serv_adr));
    
       // Prepare the address
       serv_adr.sin_family = AF_INET;                     // type : IPv4
       serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);      // ipì£¼ì†Œ
       serv_adr.sin_port = htons(atoi(argv[1]));          // í¬íŠ¸ë²ˆí˜¸
    
       // bind()ë¡œ ì„œë²„ ì†Œì¼“ì— ì£¼ì†Œì •ë³´ í• ë‹¹
       if(bind(serv_sock, (struct sockaddr*)&serv_adr, sizeof(serv_adr)) == -1)
          error_handling("bind() error");
    
       // ----------- 3. Prepare backlog ------------------
       // listen()ìœ¼ë¡œ ì„œë²„ì†Œì¼“ìœ¼ë¡œ ì˜¤ëŠ” í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ ëŒ€ê¸°
       if(listen(serv_sock, 5) == -1)
          error_handling("listen() error");
    
       clnt_adr_sz = sizeof(clnt_adr);
    
       for(i = 0; i < 5; i++)
       {
          printf("Listen....\n");
          
          // ----------- 4. Start accepting clients ---------
          // í´ë¼ì´ì–¸íŠ¸ ì ‘ì† ìš”ì²­ ëŒ€ê¸° ë° ìˆ˜ë½, í´ë¼ì´ì–¸íŠ¸ì™€ì˜ í†µì‹ ì„ ìœ„í•œ ìƒˆ socket ìƒì„±
          clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_adr, &clnt_adr_sz);
          if(clnt_sock == -1)
             error_handling("accept() error");
          else
             printf("Connected client %d \n", i + 1);
    
          // í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ì „ì†¡ëœ ìë£Œ ìˆ˜ì‹ 
          // read(int fd, void *buff, size_t nbytes)
          while((str_len = read(clnt_sock, message, BUF_SIZE)) != 0)
             // í´ë¼ì´ì–¸íŠ¸ë¡œ ìë£Œ ì†¡ì‹ 
             // write(int fd, const void *buf, size_t nbytes);
             write(clnt_sock, message, str_len);
          
          // í†µì‹ ì„ ì™„ë£Œí•˜ë©´ socket ì„ ì†Œë©¸
          close(clnt_sock);
       }
    
       // í†µì‹ ì„ ì™„ë£Œí•˜ë©´ socket ì„ ì†Œë©¸
       close(serv_sock);
       return 0;
    }
    
    void error_handling(char *message)
    {
       fputs(message, stderr);
       fputc('\n', stderr);
       exit(1);
    }
    ```
    
    **ğŸš— client.c**
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <arpa/inet.h>
    #include <sys/socket.h>
    
    #include <fcntl.h>
    #include <termios.h>
    
    #define BUF_SIZE 16
    void error_handling(char *message);
    
    typedef struct
    {
       // íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° : ì–´ë– í•œ í†µì‹  í¬íŠ¸ë¥¼ ì—´ì—ˆì„ ë•Œ ì»´í“¨í„°ê°€ ì°¾ì•„ê°€ê¸° ì‰½ê²Œ ì •ìˆ˜ë¡œ ìˆ«ì ë§¤ê¹€
       int fd;
    } SerialPort;
    
    // device : ì—´ê³  ì‹¶ì€ ì‹œë¦¬ì–¼ í¬íŠ¸ì˜ ì´ë¦„
    int serial_open(SerialPort *port, const char *device)
    {
       // open : ë¬¸ìì—´ë¡œ ì„ ì–¸ëœ ê²½ë¡œ(device)ë¥¼ ë°›ì•„ì„œ íŒŒì¼ ë””ìŠ¤í¬ë¦½í„°(fd)ë¡œ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
       port->fd = open(device, O_RDWR | O_NOCTTY | O_NDELAY);
       if (port->fd == -1)
       {
          perror("Unable to open port");
          return -1;
       }
    
       // ì‹œë¦¬ì–¼ í†µì‹  í™˜ê²½ì„ ì„¤ì •í•˜ê¸° ìœ„í•´ termios êµ¬ì¡°ì²´ë¥¼ ì„ ì–¸
       struct termios options;
    
       memset(&options, 0, sizeof(options));
    
       // ì‹œë¦¬ì–¼ í¬íŠ¸ ì´ˆê¸°í™”
       tcflush(port->fd, TCIFLUSH); 
    
       // Terminer Control ëª¨ë“œ ì„¤ì •ì„ ìœ„í•´ì„œ Get
       tcgetattr(port->fd, &options); 
       cfsetispeed(&options, B9600); // Set baud rate to 9600 (adjust as needed)
       cfsetospeed(&options, B9600);
    
       options.c_cflag |= CS8;     // 8 data bits -> ë¬¸ì í¬ê¸° ë§ˆìŠ¤í¬
       options.c_cflag &= ~PARENB; // No parity -> PARENBÂ : ì¶œë ¥ ì‹œ íŒ¨ë¦¬í‹° ìƒì„±ì„ í™œì„±í™”í•˜ê³  ì…ë ¥
       options.c_cflag &= ~CSTOPB; // One stop bit -> CSTOPB : Stop bit ìˆ˜ 1ê°œ
       // options.c_cflag &= ~CSIZE;  // Mask the character size bits
       
       // Serial Portì— ìƒˆ ì„¤ì • Set
       // ì‹œë¦¬ì–¼ í¬íŠ¸ì— ì„¤ì • ì…ë ¥ (TCSANOW : ì¦‰ì‹œ ì†ì„±ì„ ë³€ê²½ì‹œì¼œë¼)
       tcsetattr(port->fd, TCSANOW, &options);
    
       return 0;
    }
    
    void serial_close(SerialPort *port)
    {
       close(port->fd);
       port->fd = -1;
    }
    
    int serial_read(SerialPort *port, char *buffer, size_t size)
    {
       // Serial Portë¡œë¶€í„° ë°ì´í„° ìˆ˜ì‹ 
       // readì— ì˜í•´ì„œ ì‹¤ì œë¡œ ì½í˜€ì§„ ë¬¸ìì˜ ê°œìˆ˜ë¥¼ ê°–ê²Œ ë¨
       return read(port->fd, buffer, size);
    }
    
    ssize_t serial_write(SerialPort *port, char *buffer, size_t size)
    {
       // Serial Portìœ¼ë¡œ ë°ì´í„° ì†¡ì‹ 
       return write(port->fd, buffer, size);
    }
    
    int main(int argc, char *argv[])
    {
       int sock;
       char message[BUF_SIZE] = {0, };
       int str_len;
    
       // sockaddr_in êµ¬ì¡°ì²´ ë³€ìˆ˜ ì„ ì–¸
       struct sockaddr_in serv_adr;
    
       if (argc != 3)
       {
          printf("Usage : %s <IP> <port> \n", argv[0]);
          exit(1);
       }
    
       // ----------- 1. Create socket object ------------------
       // socket() : socket ìƒì„± & socket discriptor
       sock = socket(PF_INET, SOCK_STREAM, 0);
       if (sock == -1)
          error_handling("socket() error");
    
       // serial port
       SerialPort port;
       if (serial_open(&port, "/dev/ttyACM0") == -1)
       {
          return -1;
       }
    
       // ------------ 2. Connect to server-- ------------------
       // serv_sockì— bind ë¡œ ì£¼ì†Œ ë„£ê¸° ìœ„í•œ ë°‘ì‘ì—…
       memset(&serv_adr, 0, sizeof(serv_adr));
    
       // Prepare the address
       serv_adr.sin_family = AF_INET;                     // type : IPv4
       serv_adr.sin_addr.s_addr = inet_addr(argv[1]);     // ipì£¼ì†Œ
       serv_adr.sin_port = htons(atoi(argv[2]));          // í¬íŠ¸ë²ˆí˜¸
    
       // ëŒ€ìƒ ì„œë²„ ì†Œì¼“ì— ì£¼ì†Œ í• ë‹¹
       // ì£¼ì†Œ ì •ë³´ì— ì„œë²„ì˜ ì£¼ì†Œì™€ í¬íŠ¸ ë²ˆí˜¸ë¥¼ ì§€ì •í•˜ê³  ì„œë²„ì™€ ì—°ê²° ì‹œë„
       if (connect(sock, (struct sockaddr *)&serv_adr, sizeof(serv_adr)) == -1)
          error_handling("connect() error!");
       else
          puts("Connect........");
    
       while (1)
       {
          fputs("Input message(Q to quit) : ", stdout);
          fgets(message, BUF_SIZE, stdin);
    
          if (!strcmp(message, "q\n") || !strcmp(message, "Q\n"))
             break;
          
          // í´ë¼ì´ì–¸íŠ¸ë¡œ ìë£Œë¥¼ ì†¡ì‹ í•œë‹¤
          // write(int fd, const void *buf, size_t nbytes);
          write(sock, message, strlen(message));
    
          // í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ì „ì†¡ëœ ìë£Œ ìˆ˜ì‹ í•œë‹¤
          // read(int fd, void *buff, size_t nbytes)
          str_len = read(sock, message, BUF_SIZE - 1);
          message[str_len] = 0;
    
          printf("Message form server : %s", message);
    
          // serial port ë¡œ message ì „ë‹¬
          serial_write(&port, message, sizeof(message));      
       }
       
       // í†µì‹  í¬íŠ¸ë¥¼ ë‹«ì•„ ì‚¬ìš©ì„ ì¤‘ì§€
       serial_close(&port);   
    
       close(sock);   
       return 0;
    }
    
    void error_handling(char *message)
    {
       fputs(message, stderr);
       fputc('\n', stderr);
       exit(1);
    }
    ```
    
- **arduino**
    ```arduino
    // mytest3.ino

    // LiquidCrystal ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¶”ê°€
    #include <string.h>
    #include <stdio.h>
    #include <Wire.h>
    #include <LiquidCrystal_I2C.h>

    // ì¡°ì´ìŠ¤í‹± ì‰´ë“œì˜ ë²„íŠ¼ì´ ëˆ„ë¥´ëŠ” ê±¸ ì…ë ¥ë°›ê¸° ìœ„í•´ ì„ ì–¸
    const int buttonPin2 = 2;
    const int buttonPin3 = 3;
    const int buttonPin4 = 4;
    const int buttonPin5 = 5;

    // lcd ê°ì²´ ì„ ì–¸
    LiquidCrystal_I2C lcd(0x27, 16, 2);      // ì£¼ì†Œ, ì—´, í–‰

    // led ê°ì²´ ì„ ì–¸
    int GREEN = 13;
    int RED = 11;
    int BLUE = 9;

    void setup() {
    // ì‹œë¦¬ì–¼ í†µì‹ ì„ ì‹œì‘í•˜ë©°, í†µì‹ ì†ë„ëŠ” 9600
    Serial.begin(9600);                               

    pinMode(buttonPin2, INPUT_PULLUP );
    pinMode(buttonPin3, INPUT_PULLUP );
    pinMode(buttonPin4, INPUT_PULLUP );
    pinMode(buttonPin5, INPUT_PULLUP );

    lcd.init();     // LCD ì´ˆê¸°í™”
    // Print a message to the LCD
    lcd.backlight();        // LCD ë°±ë¼ì´íŠ¸ ì¼œê¸°

    pinMode(RED, OUTPUT); 
    pinMode(GREEN, OUTPUT);
    pinMode(BLUE, OUTPUT);  
    }

    // LCD ì¶œë ¥
    void LCDprint(String data) {
    lcd.setCursor(0, 0);    // 1ë²ˆì§¸, 1ë¼ì¸
    lcd.print(data);
    delay(1500);

    lcd.clear();            // ê¸€ìë¥¼ ëª¨ë‘ ì§€ì›Œë¼
    }

    void loop() {

    if(Serial.available()) {
        char data[16] = {0,};
        char buf;

        for (int i = 0; i < 16; i++) {
            buf = Serial.read();
            //Serial.print("hi");
            data[i] = buf;
        }

        //Serial.print(data);
        LCDprint(data);
        delay(500);
    }

    int X = analogRead(0);                           // ë³€ìˆ˜ Xì— ì•„ë‚ ë¡œê·¸ 0ë²ˆí•€ì— ì…ë ¥ë˜ëŠ” ì‹ í˜¸ë¥¼ ëŒ€ì…
    int Y = analogRead(1);                           // ë³€ìˆ˜ Yì— ì•„ë‚ ë¡œê·¸ 1ë²ˆí•€ì— ì…ë ¥ë˜ëŠ” ì‹ í˜¸ë¥¼ ëŒ€ì…

    int buttonValue2 = digitalRead(2);               // buttonValueê°’ ì„ ì–¸
    int buttonValue3 = digitalRead(3);
    int buttonValue4 = digitalRead(4);
    int buttonValue5 = digitalRead(5);

    if (buttonValue2 == LOW) {                       // ifë¬¸ì„ ì´ìš©í•˜ì—¬ ê° ë²„íŠ¼ì´ ëˆŒë¦¬ë©´ ì•ŒíŒŒë²³ì´ ì‹œë¦¬ì–¼ëª¨ë‹ˆí„°ì— ì¶œë ¥ë˜ë„ë¡ ì„¤ì •
        String data = "front car!";
        LCDprint(data);
    }
    if (buttonValue3 == LOW) {
        String data = "front animal!";
        LCDprint(data);
    }
    if (buttonValue4 == LOW) {
        String data = "baby in car";
        LCDprint(data);
    }
    if (buttonValue5 == LOW) {
        String data = "broken car";
        LCDprint(data);
    }

    Serial.print(X);
    Serial.print(", ");
    Serial.println(Y);

    if(X < 495) {
        // ì™¼ìª½
        if(Y < 515) {
        Serial.println('1');      
        digitalWrite(GREEN, HIGH);     
        digitalWrite(BLUE, LOW);     
        digitalWrite(RED, HIGH);         //ë¹¨ê°„ë¶ˆ ë„ê¸°
        }
        else if(Y >= 515) {
        Serial.println('1');
        digitalWrite(GREEN, HIGH);     
        digitalWrite(BLUE, HIGH);     
        digitalWrite(RED, LOW);      
        }
    }

    else if(X > 495) {
        // ì˜¤ë¥¸ìª½
        if(Y < 515) {
        Serial.println('2');    
        digitalWrite(GREEN, HIGH);     
        digitalWrite(BLUE, LOW);     
        digitalWrite(RED, HIGH);      
        }
        else if(Y >= 515) {
        Serial.println('2');
        digitalWrite(GREEN, HIGH);     
        digitalWrite(BLUE, HIGH);     
        digitalWrite(RED, LOW);      
        }
    }

    else if(X == 495) {
        // í›„ì§„
        if(Y < 515) {
        Serial.println('4');     
        digitalWrite(GREEN, LOW);     
        digitalWrite(BLUE, LOW);     
        digitalWrite(RED, HIGH);      
        }
        // ì „ì§„
        else if(Y > 515) {
        Serial.println('3');
        digitalWrite(GREEN, LOW);     
        digitalWrite(BLUE, HIGH);     
        digitalWrite(RED, LOW);      
        }
    }

    
    if (X == 495) {
        if (Y == 515) {
        digitalWrite(GREEN, LOW);     
        digitalWrite(BLUE, LOW);     
        digitalWrite(RED, LOW);  
        }
    }

    delay(1000); 
    }
    ```

### ğŸ‘¨â€ğŸ’» 5. í”„ë¡œì íŠ¸ ì„±ê³¼ ê²°ê³¼
- **ğŸš— LCD íŒì— ë’·ì°¨ì— ìƒí™© ì•Œë¦¬ê¸°**
    1. ì¡°ì´ìŠ¤í‹± ë²„íŠ¼ 4ê°œë¡œ ì§€ì •ëœ ìƒí™© ì•Œë¦¬ê¸°
        - ì¡°ì´ìŠ¤í‹± ë²„íŠ¼
            - Aë²„íŠ¼ : front car!
            ![16.png](/image/car.jpg)
            - Bë²„íŠ¼ : front animal!
            ![16.png](/image/animal.jpg)
            - Cë²„íŠ¼ : baby in car
            ![16.png](/image/baby.jpg)
            - Dë²„íŠ¼ : broken car
            ![16.png](/image/broken.jpg)
    2. TCP/IP í†µì‹ ìœ¼ë¡œ ìš´ì „ë¿ë§Œ ì•„ë‹ˆë¼ ì •ì°¨ì¤‘ì—ë„ ë©”ì‹œì§€ ì „ë‹¬í•˜ê¸°
    ![16.png](/image/T.jpg)

- **ğŸš— ì¡°ì´ìŠ¤í‹± (ìš´ì „ëŒ€) ìœ¼ë¡œ LED ì œì–´í•˜ê¸°**
    1. ì „ì§„, ì¢Œ/ìš°íšŒì „, í›„ì§„ í•  ë•Œë§ˆë‹¤ LED ì œì–´
        - ì „ì§„ : íŒŒë‘
        ![16.png](/image/ì „ì§„.png)
        - ì¢Œ/ì „ì§„ : íŒŒë‘/ì´ˆë¡
        ![16.png](/image/ì¢ŒíšŒì „.png)
        - ìš°/ì „ì§„ : íŒŒë‘/ì´ˆë¡
        ![16.png](/image/ìš°íšŒì „.png)
        - í›„ì§„ : ë¹¨ê°•
        ![16.png](/image/í›„ì§„.png)
        - ì¢Œ/í›„ì§„ : ë¹¨ê°•/ì´ˆë¡
        ![16.png](/image/ì¢Œí›„ì§„.png)
        - ìš°/í›„ì§„ : ë¹¨ê°•/ì´ˆë¡
        ![16.png](/image/ìš°í›„ì§„.png)
